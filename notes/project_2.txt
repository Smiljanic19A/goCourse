PROJECT 2

STRUCTS

project 1 had a very stupid thing - cards were a slice of strings - when in reality a deck is a slice of cards which has a value
and a suit.

To figure out the string or value - we would have to depend on string manipulation
Thats just straight out dumb.

Now we will make it with structs.

Struct
Collection of properties, related together.

Like card is a struct with suit and value

Defining a struct
type person struct {
	firstName string
	lastName  string
	age       int
}
INITIALIZING A STRUCT
	dude := person{
		firstName: "Dude",
		lastName:  "Mary",
		age:       25,
	}

U COULD ALSO JUST DO
	secondDude := person{"alex", "jognson", 33}

Zero values
    Very important
    Lets say we defined a struct like this
    var george person.
    The variable was declared but not initialized with properties - therefore Go by default gives it its
    "Zero values"
    type        zero value
    string      ""
    int         0
    float       0
    bool        false


type person struct {
	firstName string
	lastName  string
	age       int
}

func main() {
	var george person

	fmt.Println(george)
}

This code outputs
{  0}

fmt.Printf("%+v", george)
This outputs
{firstName: lastName: age:0}

u modify structs simply by accessing fields with a
.
george.firstName = ""

Structs can be embeded as well so 1 struct can contain another
Like so
type contactInfo struct {
	email string
	zip   string
}
type person struct {
	firstName string
	lastName  string
	age       int
	contact   contactInfo
}


POINTERS
RAM
What we need to understand about ram to understand pointers
Every time your computer stores something in ram its stored in a memory slot
this slot can be referenced by a 4 number value

ADDRESS         VALUE
OOO1            person{firstName: "blabla"...}              ---> jim := person{firstName: ....}             //initial value
OOO2
OOO3            person{firstName: "blabla"...               person.updateName("new_name")               // still initial value
OOO4

Pass by value
Whenever you pass a value to a function in go - the value gets coppied into a new memory slot
The original slot still exists - but go copies it into another empty container - and then runs the code
so when you modify it - you are not updating 0001 - you are updating 0003
This is all what you would reffer to as a pass by value language


Why does go do this?
A lot of good reasons
more on that later

What are & and *
&   - Gives you the memory address of the value - so for example 0001
*   - Also known as a pointer. Its saying give me the value this address is pointing at
So basically you are saying give me the value that is contained at 0001 0 so it transforms the &value into the value of the
examplatory struct in the table above

IMPORTANT
func (p *person) updateName(name string) {
	(*p).name = name
}
You notice here there is
*person         ==>         star in front of a type
*p              ==>         star in front of an actual pointer

This is outlined to describe that * is not strictly an operator - it can be used as a type description as well

Basically
You can turn a value into an address using  *value
And you can turn an address into a value using &value

The idea is - that basically when you use * in a type hint - this is not an actual pointer - it just says
im excpeceting a pointer to a person

If you define *on a receiver function = this will allow you to call the function both with a value and a pointer to a value
so both (person) and (&person)
So Go will automatically take the memory address from the value