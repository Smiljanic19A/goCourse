We will create a cards package

CARDS
newDeck -> create a list of playing cards
print -> log out the contents of a deck of cards
shuffle -> shuffle the cards
deal -> create a new hand of cards
saveToFile -> save a list of cards to a file on the local machine
newDeckFromFile -> load a list of cards from a local machine


VARIABLE DECLARATION

Go is statically typed like Java or C++

BASIC GO TYPES (NOT AN EXHAUSTIVE LIST - research this)

TYPE        EXAMPLE
bool        true, false
string      "Hello"
int         0, -10000, 99999
float64()     10.000001, 0.00009, -100.003

Multiple ways we can do this

1 - var varname type = value
2 - varname := value -> this infers the type without declaring it explicitly. This can only be done when initializing the value.


FUNCTION RETURN TYPES
    If there is no return type defined explicitly - the function is considered void.
    If its not void - u have to explicitly define the return type

    example:
    func determineCardValue() string{
    	return "Ace Of Spades"
    }

ARRAY VS SLICE IN GO
    array - fixed length
        Every element in an array must have the same type
    slice - like a list - it can grow or shrink
        Every element in a slice must have the same type
        you add an element to a slice - by using the append() function
        append takes in the original slice and the element to add - and then returns a new slice that has to get reasigned to the original
        slice - does not directly modify it

For loops
    syntax
    for index, card := range cards {
        Do something
   }

    index - index of the element in the slice/array
    card - the name of the object u will be referencing from the array
    := -> shows we are about to determine the range of the loop
    range cards - > take the slice of cards and loop over it

    why do we use :=
    because basically every step of the loop - we are reinitalizing index and card - and throwing away the old values.

GO IS NOT AN OOP LANGUAGE!

(not sure what this means) - but in go rather then creating a class that we want to instance,
we want to extend a base type with some extra functionality
To that type we want to assign functions with a receiver
This is basically like a method - a function that belongs to some instance
BASIC OOP = METHOD VS GO = FUNCTION WITH A RECEIVER (CONFUSED RN)

PROJECT STRUCTURE

main.go -> entry point
deck.go -> code that describes a deck and how it works
deck_test.go -> code to automatically test the deck


Receiver functions explanation

func (d deck) print {

} -> basically this just means any object of type deck has access to this function

d -> the actual copy of the type we are working with - available in the function with the letter d - you can name it whatever u want
deck -> the type of the copy we are working with
print -> function name

why d?
Go convention is you use a 1 or 2 letter varname that references the receiver type.

