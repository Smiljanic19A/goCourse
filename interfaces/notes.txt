The question we are asking
- Each variable has a type and each function has a return type
So many types everywhere
This can lead to us having to rewrite identical functions - and or variables (duplicate code) - just to
accomodate for different types

For example
func (d deck) shuffle(timesToShuffle int) deck {

	if timesToShuffle < 1 {
		fmt.Println("shuffle requires at least 1 times to shuffle")
		return d
	}
	if len(d) < 2 {
		fmt.Println("shuffle requires at least two times to shuffle")
		return d
	}

	fmt.Println("Shuffling deck of length", len(d))

	for i := 0; i < timesToShuffle; i++ {
		for i, _ := range d {
			n := rand.Intn(len(d) - 1)
			d[i], d[n] = d[n], d[i]
		}
	}
	return d
}

This function - must accept a deck - but any slice can be shufeled - so this is not ideal

THIS IS WHERE INTERFACES COME IN
How?

By defining functions - that will be able to receive any type that implements the interface - and then using them as such
so what we did

Defined this interface
package main

type bot interface {
	getGreeting() string
}


Implemented it in englishBot.go and spanishBot.go
Like such

package main

type EnglishBot struct {
	greeting string
}

func (e EnglishBot) getGreeting() string {
	return e.greeting
}


We just changed the receiver type for spanish bot

package main

type SpanishBot struct {
	greeting string
}

func (s SpanishBot) getGreeting() string {
	return s.greeting
}


And then in main.go - we defined pritnGreeting like such
func printGreeting(b bot) {
	fmt.Println(b.getGreeting())
}

just a function that takes in any type that implements this interface
So the flow would be

Interface (method contract)
→ struct defines method with receiver
→ compiler verifies struct satisfies interface
→ value is passed as interface type to function
→ function calls method via interface
→ concrete receiver method executes

1 confusing thing
There is no implements keyword
So the contract between interface and other types is quite different to the relationship between
classes and interfaces in for example java or php
There is no implementation that raises an error if the method is not implemented

Interfaces simply say - if u have a function that is named the same as any of the functions i have
right here - you are now an honorary member of type whatevertheinterfacenameis

Basically its a tool to implement polymorphism - which i believe is a bit different in Java or Php

This is why Go is called “structural typing” — types satisfy interfaces based on their structure,
not an explicit declaration.

IMPORTANT GOTCHA
Types in go - can be morphed into the interface type - only and only if they implement all the methods defined
in the interface type - otherwise the contract is not valid

1 more clarification of the flow
define an interface type with a method signature
-> Implement said methods in other different types
-> Those types are now also considered the interface type
-> in other places define methods that take in any type that is considered of the interface type
-> method works without having to duplicate methods for each different type - the interface type works as an umbrella

1 key rule of interfaces
INTERFACE DEFINED METHODS MUST HAVE A RECEIVER ATTACHED

Syntax of an interface
type bot interface{
methodSignature(string, int) (string, err)
}

the first() is the input param type values and the second is the return values - just like verything we did so fart


1 IMPORTANT NOTE
There is something called a concrete type in go - which is something u can directly create a value from
The opposite would be an interface type - which is an interface.

Extra interface notes
Interfaces are NOT GENERIC TYPES - go does not support generic types
Interfaces are implicit - we dont manually have to say that a custom concrete type satisfies an interface - hence the missing implements keyword
Interfaces are contracts made to help us manage types

A generic is a type or function that can work with any data type, like a Java Box<T> that can hold a String (Box<String>) or an Integer (Box<Integer>).

Important - a struct can have an interface as a field - and that can have any type that implements the interface

In GO - an interface can contain other interfaces as its fields
A good example of this is the ReaderCloser interface which has 2 other interfaces as fields - Reader and Closer

To satisfy that master interface - u have to satisfy all the sub interfaces

How the reader interface works
If something implements it - then u have the Read function - where u pass in a byte slice (make sure to size the slize accordingly with
the make function - because read does not resize the slice) -> which then just populates the slice given to it

Like so
	bs := make([]byte, 99999)
	resp.Body.Read(bs)


How io.Copy works?
It takes in 2 params
1 is any type - that implements the Writer interface - while the second is any type that implements the Reader interface
Reader reads the data - does the byte slice creation that we saw a bit above - and then writes it out to some form of output
