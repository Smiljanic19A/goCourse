The question we are asking
- Each variable has a type and each function has a return type
So many types everywhere
This can lead to us having to rewrite identical functions - and or variables (duplicate code) - just to
accomodate for different types

For example
func (d deck) shuffle(timesToShuffle int) deck {

	if timesToShuffle < 1 {
		fmt.Println("shuffle requires at least 1 times to shuffle")
		return d
	}
	if len(d) < 2 {
		fmt.Println("shuffle requires at least two times to shuffle")
		return d
	}

	fmt.Println("Shuffling deck of length", len(d))

	for i := 0; i < timesToShuffle; i++ {
		for i, _ := range d {
			n := rand.Intn(len(d) - 1)
			d[i], d[n] = d[n], d[i]
		}
	}
	return d
}

This function - must accept a deck - but any slice can be shufeled - so this is not ideal

THIS IS WHERE INTERFACES COME IN
How?

By defining functions - that will be able to receive any type that implements the interface - and then using them as such
so what we did

Defined this interface
package main

type bot interface {
	getGreeting() string
}


Implemented it in englishBot.go and spanishBot.go
Like such

package main

type EnglishBot struct {
	greeting string
}

func (e EnglishBot) getGreeting() string {
	return e.greeting
}


We just changed the receiver type for spanish bot

package main

type SpanishBot struct {
	greeting string
}

func (s SpanishBot) getGreeting() string {
	return s.greeting
}


And then in main.go - we defined pritnGreeting like such
func printGreeting(b bot) {
	fmt.Println(b.getGreeting())
}

just a function that takes in any type that implements this interface
So the flow would be

Interface (method contract)
→ struct defines method with receiver
→ compiler verifies struct satisfies interface
→ value is passed as interface type to function
→ function calls method via interface
→ concrete receiver method executes

1 confusing thing
There is no implements keyword
So the contract between interface and other types is quite different to the relationship between
classes and interfaces in for example java or php
There is no implementation that raises an error if the method is not implemented

Interfaces simply say - if u have a function that is named the same as any of the functions i have
right here - you are now an honorary member of type whatevertheinterfacenameis

Basically its a tool to implement polymorphism - which i believe is a bit different in Java or Php

This is why Go is called “structural typing” — types satisfy interfaces based on their structure,
not an explicit declaration.

IMPORTANT GOTCHA
Types in go - can be morphed into the interface type - only and only if they implement all the methods defined
in the interface type - otherwise the contract is not valid

1 more clarification of the flow
define an interface type with a method signature
-> Implement said methods in other different types
-> Those types are now also considered the interface type
-> in other places define methods that take in any type that is considered of the interface type
-> method works without having to duplicate methods for each different type - the interface type works as an umbrella