The question we are asking
- Each variable has a type and each function has a return type
So many types everywhere
This can lead to us having to rewrite identical functions - and or variables (duplicate code) - just to
accomodate for different types

For example
func (d deck) shuffle(timesToShuffle int) deck {

	if timesToShuffle < 1 {
		fmt.Println("shuffle requires at least 1 times to shuffle")
		return d
	}
	if len(d) < 2 {
		fmt.Println("shuffle requires at least two times to shuffle")
		return d
	}

	fmt.Println("Shuffling deck of length", len(d))

	for i := 0; i < timesToShuffle; i++ {
		for i, _ := range d {
			n := rand.Intn(len(d) - 1)
			d[i], d[n] = d[n], d[i]
		}
	}
	return d
}

This function - must accept a deck - but any slice can be shufeled - so this is not ideal

THIS IS WHERE INTERFACES COME IN
How?

By defining functions - that will be able to receive any type that implements the interface - and then using them as such
so what we did

Defined this interface
package main

type bot interface {
	getGreeting() string
}


Implemented it in englishBot.go and spanishBot.go
Like such

package main

type EnglishBot struct {
	greeting string
}

func (e EnglishBot) getGreeting() string {
	return e.greeting
}


We just changed the receiver type for spanish bot

package main

type SpanishBot struct {
	greeting string
}

func (s SpanishBot) getGreeting() string {
	return s.greeting
}


And then in main.go - we defined pritnGreeting like such
func printGreeting(b bot) {
	fmt.Println(b.getGreeting())
}

just a function that takes in any type that implements this interface
So the flow would be

Interface (method contract)
→ struct defines method with receiver
→ compiler verifies struct satisfies interface
→ value is passed as interface type to function
→ function calls method via interface
→ concrete receiver method executes